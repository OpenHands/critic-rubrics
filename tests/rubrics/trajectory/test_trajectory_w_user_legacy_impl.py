"""Test that the tool schema generated by AnnotateConversationWithUserRubric matches the old implementation."""


NON_USER_PROPERTIES_TO_EXPECT = {
    "follow_up_timing": {
        "type": "string",
        "enum": ["mid_conversation", "post_completion", "no_follow_up"],
        "description": "WHEN did the user follow up? Choose exactly one: mid_conversation: agent hadn't clearly finished; post_completion: agent signaled completion/hand-off; no_follow_up: no user message after the last agent message.",
    },
    "follow_up_timing_rationale": {
        "type": "string",
        "description": "Evidence for timing with a brief quote (<=25 words). Examples: â€œAgent: â€˜Hereâ€™s the final script.â€™ â€ ,  post_completion; â€œAgent: â€˜Iâ€™ll start testsâ€¦â€™ and user repliedâ€ ,  mid_conversation.",
    },
    # /* USER FOLLOW-UP PATTERNS */
    "clarification_or_restatement_detected": {
        "type": "boolean",
        "description": "User clarifies/restates or corrects interpretation. Examples: â€œThatâ€™s not what I meantâ€¦â€, â€œI meant X, not Y.â€, â€œLet me clarifyâ€¦â€",
    },
    "clarification_or_restatement_rationale": {"type": "string", "description": "Quote the user and explain briefly."},
    "correction_detected": {
        "type": "boolean",
        "description": "Agent broadly understood the intention but executed it incorrectly (technique/parameters/details). Examples: â€œUse DESC not ASC.â€, â€œRight table, wrong WHERE clause.â€, â€œSame approach, wrong sort key.â€",
    },
    "correction_rationale": {"type": "string", "description": "Quote and explain in one or two sentences."},
    "direction_change_detected": {
        "type": "boolean",
        "description": "User adds new constraints/intent not previously specified; scope/goal evolves. Examples: â€œAlso handle time zones.â€, â€œWe actually need streaming, not batch.â€, â€œSupport Windows too.â€",
    },
    "direction_change_rationale": {"type": "string", "description": "Quote and explain briefly."},
    "vcs_update_requests_detected": {
        "type": "boolean",
        "description": "User instructs forward-moving VCS updates: commit, create branch, push, open/merge PR, tag. (Revert/reset/remove ,  use removal_or_reversion_request.)",
    },
    "vcs_update_requests_rationale": {"type": "string", "description": "Quote and explain briefly."},
    "progress_or_scope_concern_detected": {
        "type": "boolean",
        "description": "User flags slowness, overcomplexity, or scope bloat. Examples: â€œThis is taking too long.â€, â€œTry a simpler approach.â€, â€œThis goes beyond what I asked.â€",
    },
    "progress_or_scope_concern_rationale": {"type": "string", "description": "Quote and explain briefly."},
    "frustration_or_complaint_detected": {
        "type": "boolean",
        "description": "User expresses dissatisfaction or irritation. Examples: â€œThis is wrong.â€, â€œYouâ€™re not listening.â€, excessive caps or punctuation (â€œ!!!â€, â€œ???â€).",
    },
    "frustration_or_complaint_rationale": {"type": "string", "description": "Quote and explain briefly."},
    "removal_or_reversion_request_detected": {
        "type": "boolean",
        "description": "User asks to remove or revert code/files/changes. Examples: â€œDelete the new script.â€, â€œUndo that migration.â€, â€œRemove these outputs.â€, â€git revertâ€.",
    },
    "removal_or_reversion_request_rationale": {"type": "string", "description": "Quote and explain briefly."},
    "other_user_issue_detected": {"type": "boolean", "description": "Any other notable user concern not covered above."},
    "other_user_issue_rationale": {"type": "string", "description": "Quote and explain briefly."},
    # /* AGENT BEHAVIORAL ISSUES */
    "misunderstood_intention_detected": {
        "type": "boolean",
        "description": "Agent misunderstood the userâ€™s goal/intent. Examples: User asked for a summary; agent produced a rewrite; user wanted high-level bullets; agent delivered full code.",
    },
    "misunderstood_intention_rationale": {"type": "string", "description": "Quote evidence concisely (<=25 words) and explain in a sentence."},
    "did_not_follow_instruction_detected": {
        "type": "boolean",
        "description": "Agent ignored or failed to comply with explicit instructions/system constraints. Examples: User: â€œDo NOT push to main.â€ Agent pushes; System says not to create a PR unless the user asks and the user didnâ€™t ask; agent creates a PR; user asked for bullet points only, agent gives long prose.",
    },
    "did_not_follow_instruction_rationale": {"type": "string", "description": "Quote the instruction and the noncompliant action."},
    "insufficient_analysis_detected": {
        "type": "boolean",
        "description": "Didnâ€™t explore existing materials (prior code/docs/examples) before acting. Examples: User points to an existing function/file that is relevant or already solves it; agent reinvents it.",
    },
    "insufficient_analysis_rationale": {"type": "string", "description": "Explain with evidence (e.g., user points to existing file)."},
    "insufficient_clarification_detected": {
        "type": "boolean",
        "description": "Failed to ask necessary questions before acting when requirements were ambiguous. Examples: Agent proceeds despite unclear acceptance criteria (locales, time zones, error thresholds) then is corrected later.",
    },
    "insufficient_clarification_rationale": {"type": "string", "description": "Quote the ambiguous instruction and note the missing questions."},
    "improper_tool_use_or_setup_detected": {
        "type": "boolean",
        "description": "Misused tools/commands or used inappropriate tools; missing/incorrect dependencies/setup. Examples: wrong command syntax; using an inappropriate tool; import errors; wrong API URL; malformed auth header.",
    },
    "improper_tool_use_or_setup_rationale": {"type": "string", "description": "Cite commands/errors and explain briefly."},
    "loop_behavior_detected": {"type": "boolean", "description": "Repeats the same failed action 3+ times without strategy change."},
    "loop_behavior_rationale": {"type": "string", "description": "Describe the repetitions and counts (e.g., â€˜same curl 3Ã— ,  401 each timeâ€™)."},
    "insufficient_testing_detected": {
        "type": "boolean",
        "description": "Skipped reasonable verification/tests for non-trivial or risky changes (trivial edits may be acceptable). Examples: No run/validation for a new parser; no check that a migration applies cleanly; no sanity check of output.",
    },
    "insufficient_testing_rationale": {"type": "string", "description": "Describe what should have been tested and why."},
    "insufficient_debugging_detected": {
        "type": "boolean",
        "description": "Did not investigate or reduce failing behavior when needed to make progress. Examples: Ignores stack trace; no isolation of failure; proceeds while errors persist.",
    },
    "insufficient_debugging_rationale": {"type": "string", "description": "Quote the error and explain the missing debugging steps."},
    "incomplete_implementation_detected": {"type": "boolean", "description": "Delivered unfinished or non-functioning work. Examples: TODO/FIXME left; stub methods; code that cannot run."},
    "incomplete_implementation_rationale": {"type": "string", "description": "Point to the incomplete parts and impact."},
    "file_management_errors_detected": {
        "type": "boolean",
        "description": "Wrong paths, overwrites, misplaced/extra (unnecessary) files. Examples: writes into wrong directory; overwrites config; creates unwanted artifacts.",
    },
    "file_management_errors_rationale": {"type": "string", "description": "Describe exact paths/actions and consequences."},
    "scope_creep_detected": {"type": "boolean", "description": "Implemented unrequested features without approval. Examples: adds a dashboard or endpoint not asked for."},
    "scope_creep_rationale": {"type": "string", "description": "Explain how it exceeds the ask."},
    "risky_actions_or_permission_detected": {
        "type": "boolean",
        "description": "Risky steps without the user's explicit consent. Examples: git push to main; deleting existing files in a repo (deleting files created by the agent itself is fine); altering credentials.",
    },
    "risky_actions_or_permission_rationale": {"type": "string", "description": "Describe the risky action and lack of consent."},
    "other_agent_issue_detected": {"type": "boolean", "description": "Any other agent-side problem not covered above."},
    "other_agent_issue_rationale": {"type": "string", "description": "Describe and cite brief evidence."},
    # /* INFRASTRUCTURE (EXTERNAL vs AGENT-CAUSED) */
    "infrastructure_external_issue_detected": {
        "type": "boolean",
        "description": "Environment/platform limits outside agent control. Examples: provider outage; disk full on a managed runner; missing enterprise API key; network failure not caused by agent.",
    },
    "infrastructure_external_issue_rationale": {"type": "string", "description": "Quote the error/status and explain briefly."},
    "infrastructure_agent_caused_issue_detected": {
        "type": "boolean",
        "description": "Infrastructure faults introduced by the agentâ€™s prior actions. Examples: agent leaves server on port 8000 -> later start on 8000 fails; agent fills disk with logs -> later writes fail.",
    },
    "infrastructure_agent_caused_issue_rationale": {"type": "string", "description": "Describe the agent-caused condition and the resulting failure."},
}


def test_annotate_conversation_with_user_rubric_schema_consistency():
    """Test that AnnotateConversationWithUserRubric.tool_description generates parameters
    that match (or are a superset of) legacy ANNOTATION_TOOL parameters."""

    # Access the tool description through the class without instantiating
    # We'll create a mock instance by accessing the class's model_fields directly

    from critic_rubrics.prediction import BasePrediction
    from critic_rubrics.rubrics.trajectory import annotate_conversation_with_user_rubrics

    # Replicate the tool_description logic from BaseRubrics
    props = {}

    for feature in annotate_conversation_with_user_rubrics.features:
        ann = feature.prediction_type
        if not isinstance(ann, type) or not issubclass(ann, BasePrediction):
            continue
        assert feature.description is not None, f"Field {feature.name} must have a description"
        field_desc = feature.description.strip()

        props.update(
            ann.to_tool_properties(
                field_name=feature.name,
                field_description=field_desc,
                rationale_description="Brief evidence/quote (<=25 words) explaining why.",
            )
        )

    required = sorted(props.keys())  # REQUIRED_ALL is True

    generated_tool = {
        "type": "function",
        "function": {
            "name": "annotate_conversation",
            "description": "Annotate agent conversation after agent work.",
            "parameters": {
                "type": "object",
                "properties": props,
                "required": required,
            },
        },
    }

    # Extract parameters from both schemas
    expected_params = NON_USER_PROPERTIES_TO_EXPECT
    generated_params = generated_tool["function"]["parameters"]["properties"]

    # Verify that every parameter in ANNOTATION_TOOL exists in the generated schema
    for param_name, expected_schema in expected_params.items():
        assert param_name in generated_params, f"Missing parameter: {param_name}"

        generated_schema = generated_params[param_name]

        # Check type matches exactly
        assert generated_schema["type"] == expected_schema["type"], f"Type mismatch for {param_name}: expected {expected_schema['type']}, got {generated_schema['type']}"

        # Check description matches exactly (except for _rationale fields which are expected to differ)
        if not param_name.endswith("_rationale"):
            # Normalize quotes for comparison (smart quotes vs regular quotes shouldn't matter)
            def normalize_quotes(text):
                # First convert smart quotes to regular quotes using actual Unicode characters
                text = text.replace("\u201c", '"').replace("\u201d", '"')  # Smart double quotes to regular
                text = text.replace("\u2018", "'").replace("\u2019", "'")  # Smart single quotes to regular
                # Then convert all double quotes to single quotes for consistent comparison
                text = text.replace('"', "'")
                return text

            expected_desc = normalize_quotes(expected_schema["description"])
            generated_desc = normalize_quotes(generated_schema["description"])
            assert generated_desc == expected_desc, f"Description mismatch for {param_name}: expected '{expected_desc}', got '{generated_desc}'"
        else:
            # For rationale fields, just verify they both have descriptions
            assert "description" in generated_schema, f"Generated schema missing description for {param_name}"
            assert "description" in expected_schema, f"Expected schema missing description for {param_name}"

    # Verify basic tool structure matches
    assert generated_tool["type"] == "function"
    assert generated_tool["function"]["name"] == "annotate_conversation"

    # Note: The generated tool may have additional parameters beyond those in ANNOTATION_TOOL
    # This is acceptable as mentioned in the requirements
    print(f"âœ… All {len(expected_params)} expected parameters found and match exactly")
    print(f"ðŸ“Š Generated tool has {len(generated_params)} total parameters ({len(generated_params) - len(expected_params)} additional)")

    # Show any additional parameters for visibility
    additional_params = set(generated_params.keys()) - set(expected_params.keys())
    if additional_params:
        print(f"ðŸ” Additional parameters in generated schema: {sorted(additional_params)}")

    # Assert all parameters are required
    assert generated_tool["function"]["parameters"]["required"] == sorted(generated_params.keys()), "Not all parameters are marked as required"
